## 고차 함수란 ?

고차 함수는(Higher order function)는 함수를 인자로 전달 받거나, 함수를 결과로 반환하는 함수이다. 고차 함수는 인자로 받은 함수를 필요한 시점에 호출하거나, `클로저`를 생성하여 반환한다. 자바스크립트의 함수는 `일급 객체` 이므로 값처럼 인자로 전달할 수 있으며, 반환할 수도 있다.

> `클로저`는 자신이 생성될 때의 환경(Lexical environment)을 기억하는 함수이다. 클로저가 가장 유용하게 사용되는 상황은 <b>현재 상태를 기억하고 변경된 최신 상태를 유지</b>할 때 이다.

> `일급 객체(first-class object)`란 생성, 대입, 연산, 인자 또는 반환값으로서의 전달 등 프로그래밍 언어의 기본적 조작을 제한없이 사용할 수 있는 대상을 의미한다.

## 고차 함수 특징

고차 함수는 외부 상태 변경이나 가변(mutable) 데이터를 피하고 <b>불변성(Immutability)</b>을 지향하는 `함수형 프로그래밍`에 기반을 두고 있다.

> `함수형 프로그래밍`은 순수 함수(pure function)와 보조 함수의 조합을 통해 로직 내에 존재하는 조건문과 반복문을 제거하여 복잡성을 해결하고, 변수의 사용을 억제하여 상태 변경을 피하려는 프로그래밍 패러다임이다. 조건문이나 반복문은 로직의 흐름을 이해하기 어렵게 하여 가독성을 해치고, 변수의 값은 누군가에 의해 언제든지 변경될 수 있어 오류 발생의 근본적 원인이 될 수 있기 때문이다.  
> 함수형 프로그래밍은 결국 순수 함수를 통해 <b>부수 효과(Side effect)를 최대한 억제</b>하여 오류를 피하고 프로그램의 안정성을 높이려는 노력의 한 방법이라고 할 수있다.

## 1. forEach

- forEach 메소드는 for 문 대신 사용할 수 있다.
- 배열을 순회하며 배열의 각 요소에 대해서 인자로 주어진 콜백함수를 실행한다. <b>반환 값은 undefined이다</b>
- 콜백 함수의 매개변수를 통해 배열 요소의 값, 요소 인덱스, forEach 메소드를 호출한 배열, 즉 this를 전달 받을 수 있다.
- forEach 메소드는 원본 배열(this)을 변경하지 않는다. 하지만 콜백 함수는 원본 배열(this)을 변경할 수는 있다.
- <b>forEach 메소드는 for문과는 달리 break 문을 사용할 수 없다.</b> 다시말해, 배열의 모든 요소를 순회하며 중간에 순회를 중단할 수 없다.
- forEach 메소드는 for 문에 비해 성능이 좋지는 않다. 하지만 for 문보다 가독성이 좋으므로 적극 사용을 권장한다.

```javascript
// highlight-start
// highlight-end
const numbers = [1, 2, 3];
let pows = [];

// for 문으로 순회
for (let i = 0; i < numbers.length; i++) {
  pows.push(numbers[i] ** 2);
}

console.log(pows); // [1, 4, 9]
pows = [];

// forEach 메소드로 순회 (화살표 함수)
numbers.forEach((item) => pows.push(item ** 2));

console.log(pows); // [1, 4, 9]
pows = [];

// forEach 메소드로 순회 (일반 함수)
numbers.forEach(function (item) {
  pows.push(item ** 2);
});

console.log(pows); // [1, 4, 9]
```

```javascript
const numbers = [1, 3, 5, 7, 9];
let total = 0;

// forEach 메소드는 인수로 전달한 보조 함수를 호출하면서
// 3개 (배열 요소의 값, 요소 인덱스, this)의 인수를 전달한다.
// 배열의 모든 요소를 순회하며 합산한다.

numbers.forEach((item, index, self) => (total += item));

// reduce를 사용해도 위와 동일한 결과를 얻을 수 있다.
// total = numbers.reduce((pre, cur) => pre + cur);

console.log(total); // 25
```

```javascript
const numbers = [1, 2, 3, 4];

// forEach 메소드는 원본 배열(this)을 변경하지 않는다. 하지만 콜백 함수는 원본 배열(this)을 변경할 수는 있다.
// 원본 배열을 직접 변경하려면 콜백 함수의 3번째 인자(this)를 사용한다.

numbers.forEach((item, index, self) => (self[index] = Math.pow(item, 2)));

console.log(numbers); //[1, 4, 9, 16]
```

```javascript
// forEach 메소드는 for 문과는 달리 break 문을 사용할 수 없다.

const numbers = [1, 2, 3];
numbers.forEach((item, index, self) => {
  if (item > 1) break;  // SyntaxError: Illegal break statement
})
```
