# [리얼월드 HTTP] 스터디 3주차

<br />

리얼월드 HTTP 책 3주차 스터디 3주차이다. 책의 핵심 내용을 토대로 추가 공부를 하였다.

<br />

## 단순한 폼 전송 방식 x-www-form-urlencoded

폼을 사용한 **POST** 전송에는 몇 가지 방식이 존재하는데 그 중 가장 단순한 전송 방식이 application/x-www-form-urlencoded 방식이다.

이 폼 전송 방식의 Body는 키와 값이 `=`로 연결되고 각 항목이 `&`로 연결된 문자열이다.

```
title=Avengers&hero=Iron Man
```

이렇게 Post의 Body에 추가하여 값을 보내게 되면, 브라우저는 Body에 있는 값을 [변환 포맷](https://datatracker.ietf.org/doc/html/rfc1866#section-8.2.1)에 따라 변환을 실시한다.
서버에서는 해당 값을 변환 알고리즘으로 복원하여 값을 받을 수 있다.

<br />

## 폼을 이용한 파일 전송 방식 Multipart/form-data

`Multipart/form-data` 방식은 웹 클라이언트가 요청을 보낼 때, Body부분에 데이터를 여러 부분으로 나눠서 보내는 방식이다.

HTML의 폼에서는 옵션으로 **멀티파트 폼 형식**이라는 인코딩 타입을 선택할 수 있다.

```HTML
<form method="POST" entype="multipart/form-data">
  	<input type="file" />
</form>
```

### Multipart/form-data 방식은 왜 생긴 것일까 ??

다음 예시를 보자

사진을 업로드 할때, 사진을 담은 `input`과, 사진 설명을 담은 `input` 2개가 Body로 들어간다고 해보자.
사진의 `Content-type`은 `image/jpeg`일 것이고 사진 설명의 `Content-type`은 `application/x-www-form-urlencoded`가 될 것이다.
두 종류의 데이터가 하나의 `HTTP Request Body`에 들어가야 하는데, 한 `Body`에서 이 2종류의 데이터를 구분해서 넣지 못하기 때문에 2종류 이상의 데이터를 넣기 위해 `Multipart/form-data` 방식이 생기게 된 것이다.

### Multipart/form-data를 수동으로 구성하는 방법

헤더에 `Content-Type: multipart/form-data`으로 콘텐츠 타입을 준 뒤에 경계 문자열을 준다.
경계 문자열은 각 브라우저가 독자적인 포맷으로 랜덤하게 만들어낸다.  
`Content-type: multipart/form-data; boundary=——WebKitFormBoundary....`

각각의 파트에는 헤더가 들어가고 `Content-Disposition: form-data; name=" ... "` 과 같은 폼 필드의 정보를 추가해준다.

모든 파트가 끝나면 경계 문자열 뒤에 --를 추가해준다.

```
------WebKitFormBoundaryt0Yasdasd
Content-Disposition: form-data; name="movie"

Avengers
------WebKitFormBoundaryt0Yasd23
Content-Disposition: form-data; name="IronMan"

Thor
------WebKitFormBoundaryt0Yasd42d--
```

<br />

## 콘텐츠 네고시에이션 (콘텐츠 협상)

콘텐츠 네고시에이션은 **사용자 에이전트가 사용자에게 가장 알맞는 형태의 자료를 제공해 주기 위해서**(예를들어, 언어, 이미지포맷, 콘텐츠 인코딩 등) 명시하는 것이다.

이를 한글로 풀어보면 **콘텐츠**를 어떤 형태로 받을지 **협상**한다 정도가 될 것이다.

> **에이전트란?**  
> 누군가를 위하여 정해진 일을 대신 해 주는 컴퓨터 프로그램을 통칭하는 것  
> 사용자가 컴퓨터 개입없이 특정업무를 사용자 대신 자율적으로 수행하는 S/W  
> **쉽게 말해서**, 사용자를 대표하는 컴퓨터 프로그램으로, **웹개발** 맥락에서는 **브라우저**를 의미한다.

<br />

### 사용자에게 최적의 콘텐츠를 제공해준다.

같은 콘텐츠이지만 여러개의 페이지를 지닌 웹페이지가 있다. 예를 들어, 한국에서 구글에 접속하면 한국어 페이지가 나오고, 미국에서 구글에 접속하면 영어 페이지가 나온다. 서로 다른 언어를 사용하는 브라우저가 같은 URI에 접근할 때 각각 영어, 한국어 웹페이지를 표시한다.

<br />

### 콘텐츠 네고시에이션 종류

콘텐츠 네고시에이션에는 크게 두가지 방법이 있다. 첫 번째는 **서버 주도적 네고시에이션** 두 번째는 **에이전트 주도적 네고시에이션**이다. 흔히 첫 번째 방법이 통상적으로 사용되는 방법이라고 한다.

#### 서버 주도적 네고시에이션

서버 주도적 네고시에이션은 콘텐츠 네고시에이션의 주도권이 서버에 있다고 보면 된다. 서버측에서 `Request` 헤더 필드의 정보를 참고해서 자동으로 처리한다. 브라우저가 보내는 정보를 근거로 판단하기 때문에 유저에게 적절한 것이 제공되었다고는 할 수 없다.

http/1.1 기준으로 서버 주도적 네고시에이션을 일으키게 하는 특정 헤더 목록은 다음과 같다.  
`Accept`, `Accept-Language`, `Accept-Charset`, `Accept-Encoding`

| 요청 헤더           |                           설명                            |
| :------------------ | :-------------------------------------------------------: |
| **Accept**          | 유저가 선호하는 미디어 타입을 서버에게 달라고 요청하는 것 |
| **Accept-Language** |    유저가 선호하는 언어를 서버에게 달라고 요청하는 것     |
| **Accept-Charset**  | 유저가 선호하는 문자 인코딩을 서버에게 달라고 요청하는 것 |
| **Accept-Encoding** | 유저가 선호하는 압축 인코딩을 서버에게 달라고 요청하는 것 |

<br />

#### 에이전트 주도적 네고시에이션

에이전트 주도적 네고시에이션은 클라이언트 측에서 콘텐츠 네고시에이션을 하는 방식이다.
브라우저에 표시된 선택지 중에 유저가 직접 선택한다 (ex. 유저가 직접 한국어, 일본어, 영어 선택)
Javascript 등을 통해 웹페이지에서 자동적으로 정하는 것도 있다. 예를 들면 OS의 종류나 브라우저의 종류 등에 의해 PC용과 스마트폰용의 웹페이지를 자동으로 전환하는 것이 해당된다.

<br />

## 쿠키

쿠키란 웹사이트의 정보를 브라우저 쪽에 저장하는 작은 파일이다. 일반적으로 데이터베이스는 클라이언트가 데이터베이스 관리 시스템에 SQL문을 사용하여 데이터를 저장하지만, 쿠키의 경우는 거꾸로 서버가 클라이언트(브라우저)에 '이 파일을 보관해줘' 라고 쿠키 저장을 지시한다.

### 쿠키의 잘못된 사용법

쿠키는 편리한 기능이지만, 몇 가지 제약이 있다.  
첫번째는 **영속성** 문제이다. 쿠키는 어떤 상황에서도 확실하게 저장되는 것이 아니다. 브라우저 환경이나, 사용자가 직접 삭제 할 수 있기 때문에 쿠키를 데이터베이스 대신으로 쓸 수는 없다.
**그러므로 사라지더라도 문제가 없는 정보나 서버 정보로 복원할 수 있는 자료를 저장하는 용도에 적합하다**

두번째는 **용량** 문제이다. 쿠키는 최대 4킬로바이트로 정해져 있어서 **제한된 용량 때문에 데이터베이스로 사용하는데 제약이 된다.**

마지막은 **보안** 문제이다. HTTP 통신에서는 쿠키가 평문으로 전송된다. 매 요청 시 쿠키가 송수신 되는데, 보여선 곤란한 비밀번호 등이 포함되면 노출될 위험성이 있다. 그리고 아무리 암호화된다고 해도 사용자가 자유롭게 접근할 수 있기 때문에 **인증 정보나 사라져도 문제가 없는 정보만 쿠키에 넣는 편이 좋다**
