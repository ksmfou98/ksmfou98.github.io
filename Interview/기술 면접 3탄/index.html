<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.4">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="이도현 Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="이도현 Blog Atom Feed"><title data-react-helmet="true">기술 면접 3탄 | 이도현</title><meta data-react-helmet="true" property="og:url" content="https://ksmfou98.github.io/Interview/기술 면접 3탄"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" name="google-site-verification" content="awHB70BrXtna5akJyDss2-cHM9l9XMjzLV1z23DiMR0"><meta data-react-helmet="true" property="og:title" content="기술 면접 3탄 | 이도현"><meta data-react-helmet="true" name="description" content="1. http와 https 통신 방식의 차이를 설명해주세요."><meta data-react-helmet="true" property="og:description" content="1. http와 https 통신 방식의 차이를 설명해주세요."><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://ksmfou98.github.io/Interview/기술 면접 3탄"><link data-react-helmet="true" rel="alternate" href="https://ksmfou98.github.io/Interview/기술 면접 3탄" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://ksmfou98.github.io/Interview/기술 면접 3탄" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.2f4915af.css">
<link rel="preload" href="/assets/js/runtime~main.fc2bc6b0.js" as="script">
<link rel="preload" href="/assets/js/main.0df017ab.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="도현위키 Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="도현위키 Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">도현위키</b></a><a class="navbar__item navbar__link" href="/">Docs</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/ksmfou98" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button" title="Scroll to top"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/">도현위키</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Books</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">WebRTC</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Javascript</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Project</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Typescript</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Interview</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Interview/기술 면접 1탄">기술 면접 1탄</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Interview/기술 면접 2탄">기술 면접 2탄</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/Interview/기술 면접 3탄">기술 면접 3탄</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Interview/기술 면접 4탄">기술 면접 4탄</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Interview/기술 면접 5탄">기술 면접 5탄</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">React</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">ETC</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Git</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_2rXS"><div class="docItemContainer_1EXp"><article><div class="tocCollapsible_1PrD tocMobile_Ftrd"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="markdown"><header><h1 class="h1Heading_27L5">기술 면접 3탄</h1></header><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="1-http와-https-통신-방식의-차이를-설명해주세요"></a>1. http와 https 통신 방식의 차이를 설명해주세요.<a class="hash-link" href="#1-http와-https-통신-방식의-차이를-설명해주세요" title="Direct link to heading">#</a></h2><b>http</b><ul><li>http 방식은 네트워크상에서 정보를 누군가가마음대로 열람, 수정이 가능하다.</li><li>http 방식이 https 방식보다 빠르다.</li><li>http 방식은 민감한 정보를 다룰 때 항상 변조, 해킹 가능성을 생각해야 한다.</li></ul><b>https</b><ul><li>https 방식은 누가 볼 수 없도록 막아놨다.</li><li>https 방식은 http 방식보다 느리다.</li><li>https 방식은 설치 및 인증서를 유지하는데 추가적인 비용이 발생한다.</li></ul><b>따라서, 민감한 정보가 있는 페이지의 경우 https응 이용하고, 그럴 필요가 없으면 http로 만들면 된다.</b><br><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="2-oop에-특징에-대해-설명해-주세요"></a>2. OOP에 특징에 대해 설명해 주세요.<a class="hash-link" href="#2-oop에-특징에-대해-설명해-주세요" title="Direct link to heading">#</a></h2><p>Object Oriented Programming 객체지향 프로그래밍이라고 한다. 특징은 크게 4가지가 있다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="상속"></a>상속<a class="hash-link" href="#상속" title="Direct link to heading">#</a></h3><ul><li>상속이란 기존 상위클래스에 근거하여 새롭게 클래스와 행위를 정의할 수 있게 도와주는 개념이다.</li><li>기존 클래스에 기능을 가져와 재사용할 수 있으면서도 동시에 새롭게 만든 클래스에 새로운 기능을 추가할 수 있게 만들어 준다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="다형성"></a>다형성<a class="hash-link" href="#다형성" title="Direct link to heading">#</a></h3><ul><li>다형성은 상속을 통해 기능을 확장하거나 변경하는 것을 가능하게 해준다.</li><li>이를 통해 코드의 재사용, 코드길이 감소가 되어 유지보수가 용이하도록 도와주는 개념이다.</li><li>쉽게 말해, 같은 동작이지만 다른 결과물이 나올때 이를 <code>다형성</code>이라고 생각하면 된다.</li></ul><blockquote><p>예를 들어, 도형을 만들다 라는 기능이 있으면, 어떤 거는 삼각형 도형을 만들고, 어떤거는 사각형 도형을 만드는 거라고 비유해서 생각하면 된다.</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="캡슐화"></a>캡슐화<a class="hash-link" href="#캡슐화" title="Direct link to heading">#</a></h3><ol><li>은닉화 : 보통 데이터를 은닉시킨다고 표현하는데, 외부에서 쉽게 데이터를 접근할 수 없게 만듬. (접근제어자, setter, getter 사용)</li><li>데이터 캡슐화 : 필드와 메소드를 클래스로 묶음</li></ol><blockquote><p>예를 들자면, 은행이라는 클래스는 잔고라는 변수가 있고 그 잔고를 조회하거나, 잔고를 수정할 수 있는 메서드등이 있다고 가정하자.<br>
캡슐화를 하는 중요한 목적은 바로 정보의 은닉화이다. 잔고라는 변수가 만약 public 으로 선언되어있다고 생각해보자.<br>
200만원인 나의 잔고가 누군가 접근에 의해 0원이 될수도 있다. 따라서 잔고라는 변수를 바로 접근할 수 없도록 private로 선언하고 데이터를 보호하는 것이다.</p><p>이렇게 보호된 변수는 getter나 setter등의 메서드를 통해서만 간접적으로 접근이 가능하도록 하는 것이 바로 캡슐화의 중요한 목적이다.</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="추상화"></a>추상화<a class="hash-link" href="#추상화" title="Direct link to heading">#</a></h3><ul><li><p>추상적으로 생각해서 일단 큰 틀의 클래스를 구현하고, 거기에 최소 이러한 공통적인 요소나 필수적인 요소는 들어갔으면 하는 바램에서 만든 것이 <code>추상클래스</code> 이다.</p></li><li><p>이 과정에서 공통적인 요소나 특징을 추출하는 과정이 <code>추상화</code> 이다.</p></li></ul><blockquote><p>예를 들자면, 벤츠, 아우디, 소나타, 티코, 벤틀리 등등 우리가 생각하는 여러 종류의 자동차가 있다.<br>
이것을 다 클래스화하고 변수와 메서드 등을 개별적으로 만드는것은 무모한 짓이다.<br>
따라서 방금 나열한 자동차들의 공통적인 요소나 특징을 추출하는 과정인 추상화를 거쳐 요소를 끄집어 내면, 바퀴, 배기통, 핸들, 차문, 유리창 등 필수적인 부품이 있고 바퀴는 굴러가야하며, 핸들은 좌우로 돌아가야하고 차문은 열려야 한다는 공통적인 행동 즉 어떤 차든 필수적으로 필요한 메서드가 추출된다.</p><p>이러한 과정이 추상화하는 과정이다. 이렇게 추상적으로 끄집어 낸 개념들을 큰 틀에서 클래스로 만든 것이 바로 추상클래스이다.</p></blockquote><br><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="3-react-hooks에는-어떤-종류가-있나요--그리고-각각의-용도를-설명해주세요"></a>3. React hooks에는 어떤 종류가 있나요 ?? 그리고 각각의 용도를 설명해주세요.<a class="hash-link" href="#3-react-hooks에는-어떤-종류가-있나요--그리고-각각의-용도를-설명해주세요" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usestate"></a>useState<a class="hash-link" href="#usestate" title="Direct link to heading">#</a></h3><p>가장 많이 사용되는 훅으로써, 함수형 컴포넌트에서도 <code>state</code>를 지닐 수 있게 해주는 훅이다. <code>state</code>는 화면 렌더링과 관련된 데이터를 다룰 때 쓰인다. 이는 곧 <b>state를 바꾸면 컴포넌트가 리랜더링된다</b>는 것을 의미한다.</p><ul><li><b>상태 변경 함수</b>를 이용해서 state 값을 변경할 수 있다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly jsx"><pre tabindex="0" class="prism-code language-jsx codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token comment" style="color:rgb(98, 114, 164)">// 기본 형태</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">const</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token plain">상태</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> 상태변경함수</span><span class="token punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function" style="color:rgb(80, 250, 123)">useState</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">초기값</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">const</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token plain">loading</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> setLoading</span><span class="token punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function" style="color:rgb(80, 250, 123)">useState</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token boolean">false</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="useeffect"></a>useEffect<a class="hash-link" href="#useeffect" title="Direct link to heading">#</a></h3><b> useEffect는 클래스형 컴포넌트의 라이프사이클을 대체하는 Hook </b> 으로 리액트 컴포넌트가 렌더링될 때마다 특정 작업을 수행할 수 있도록 설정할 수 있다.<br><b>뒷정리(cleanup) 함수</b>를 return하면 컴포넌트가 언마운트되기 전에 지정한 작업을 수행할 수 있다. (class형 컴포넌트에서 componentWillUnmount의 역할)<br>클래스형 컴포넌트의 라이프사이클과 다르게 컴포넌트 중심이 아닌 <b>데이터 중심으로 실행</b>된다.<br><br><ol><li>deps 값이 있으면 그 값을 추적해서 값이 변경될 때마다 실행된다.</li><li>deps에 빈 배열을 넣으면 마운트 될 때 처음 한 번만 실행된다.</li><li>deps 값을 아예 넣지 않으면 리렌더링 될 때마다 실행된다.</li></ol><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly jsx"><pre tabindex="0" class="prism-code language-jsx codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token function" style="color:rgb(80, 250, 123)">useEffect</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token operator">=&gt;</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  console</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token function" style="color:rgb(80, 250, 123)">log</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token string" style="color:rgb(255, 121, 198)">&#x27;render&#x27;</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token plain">deps</span><span class="token punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="useref"></a>useRef<a class="hash-link" href="#useref" title="Direct link to heading">#</a></h3><p>ref 는 DOM 노드나 React 엘리먼트에 접근하는 방법을 제공한다. <b>useRef는 함수형 컴포넌트에서 ref를 쉽게 사용할 수 있도록 해주는 Hook</b>이다. (HTML의 id와 유사한 기능)  </p><b>화면 리렌더링과 관련이 없는 컴포넌트 로컬 변수를 사용해야 할 떄도 활용</b>할 수있다.<h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usecallback"></a>useCallback<a class="hash-link" href="#usecallback" title="Direct link to heading">#</a></h3><b>useCallback은 함수를 캐싱(또는 메모이제이션)할 때 사용하는 Hook</b>이다.<br>컴포넌트의 렌더링 성능을 최적화할 때 활용한다. <br>두 번째 파라미터 값으로 들어가는 <b>deps(dependencylist)배열이 비어있으면 컴포넌트가 렌더링 될 때 만들었던 함수를 계속 재사용</b>한다 <br><b>deps에 특정한 값이 있으면 그 값이 바뀔 때마다 함수를 새로 만들어 캐싱</b>한다.<br>deps는 여러 개의 값을 가질 수 있고 useCallback은 이 값들을 계속 추적하면서 값이 바뀌는지 확인한다.<ul><li>deps 값이 있으면 값이 바뀔 때만 함수를 새로 만들어서 캐싱</li><li>deps 값이 비어 있으면 컴포넌트가 렌더링 될 때 만들었던 함수를 계속해서 재사용</li></ul><blockquote><p>메모이제이션이란?<br>
메모이제이션(memoization)은 컴퓨터 프로그램이 동일한 계산을 반복해야 할 떄,<br>
이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술이다.</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usememo"></a>useMemo<a class="hash-link" href="#usememo" title="Direct link to heading">#</a></h3><b>useMemo는 컴포넌트 내부에서 발생하는 연산을 최적화할 때 사용되는 Hook</b>이다.<br>렌더링 하는 과정에서 특정 값이 바뀌었을 때만 연산을 실행하고, 원하는 값이 바뀌지 않았다면 이전에 연산했던 결과를 다시 사용한다. <br>useCallback과 마찬가지로 deps 배열이 존재하며 <b>deps 배열 내부의 값이 달라지면 기존 캐싱된 것을 버리고 새로 값을 구하는 방식</b>으로 실행한다.<blockquote><b>useMemo와 useCallback</b><p>useCallback은 함수 자체를 캐싱하고, useMemo는 값을 캐싱한다. (값이 함수일 수도 있다.)<br>
useMemo와 useCallback 형식이 유사하다.</p></blockquote><br><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="참고-및-자료-출처"></a>참고 및 자료 출처<a class="hash-link" href="#참고-및-자료-출처" title="Direct link to heading">#</a></h2><ul><li><a href="https://sunnykim91.tistory.com/121" target="_blank" rel="noopener noreferrer">https://sunnykim91.tistory.com/121</a></li><li><a href="https://interconnection.tistory.com/112" target="_blank" rel="noopener noreferrer">https://interconnection.tistory.com/112</a></li><li><a href="https://velog.io/@white-jang/React-Hooks-%EC%A0%95%EB%A6%AC" target="_blank" rel="noopener noreferrer">https://velog.io/@white-jang/React-Hooks-%EC%A0%95%EB%A6%AC</a></li></ul></div><footer class="row docusaurus-mt-lg"><div class="col"><a href="https://github.com/ksmfou98/ksmfou98.github.io/edit/master/docs/Interview/기술 면접 3탄.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_1szQ"></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/Interview/기술 면접 2탄"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 기술 면접 2탄</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/Interview/기술 면접 4탄"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">기술 면접 4탄 »</div></a></div></nav></div><div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1-http와-https-통신-방식의-차이를-설명해주세요" class="table-of-contents__link">1. http와 https 통신 방식의 차이를 설명해주세요.</a></li><li><a href="#2-oop에-특징에-대해-설명해-주세요" class="table-of-contents__link">2. OOP에 특징에 대해 설명해 주세요.</a><ul><li><a href="#상속" class="table-of-contents__link">상속</a></li><li><a href="#다형성" class="table-of-contents__link">다형성</a></li><li><a href="#캡슐화" class="table-of-contents__link">캡슐화</a></li><li><a href="#추상화" class="table-of-contents__link">추상화</a></li></ul></li><li><a href="#3-react-hooks에는-어떤-종류가-있나요--그리고-각각의-용도를-설명해주세요" class="table-of-contents__link">3. React hooks에는 어떤 종류가 있나요 ?? 그리고 각각의 용도를 설명해주세요.</a><ul><li><a href="#usestate" class="table-of-contents__link">useState</a></li><li><a href="#useeffect" class="table-of-contents__link">useEffect</a></li><li><a href="#useref" class="table-of-contents__link">useRef</a></li><li><a href="#usecallback" class="table-of-contents__link">useCallback</a></li><li><a href="#usememo" class="table-of-contents__link">useMemo</a></li></ul></li><li><a href="#참고-및-자료-출처" class="table-of-contents__link">참고 및 자료 출처</a></li></ul></div></div></div></div></main></div></div></div>
<script src="/assets/js/runtime~main.fc2bc6b0.js"></script>
<script src="/assets/js/main.0df017ab.js"></script>
</body>
</html>